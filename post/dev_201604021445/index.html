  <!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <title> Go - EBNF &middot; 那年江湖，遇见你 </title>
  
  <link rel="stylesheet" type="text/css" href="https://alimy.github.io/css/uno.css" />
  <link rel="stylesheet" type="text/css" href="https://alimy.github.io/css/lightGallery.css" />
  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://alimy.github.io/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://alimy.github.io/favicon.png">
  
  <script src="https://alimy.github.io/js/jquery.min.js"></script>
  <script src="https://alimy.github.io/js/main.min.js"></script>

  
  <script>
    "use strict";

    !function () {
      var t = window.driftt = window.drift = window.driftt || [];
      if (!t.init) {
        if (t.invoked) return void (window.console && console.error && console.error("Drift snippet included twice."));
        t.invoked = !0, t.methods = ["identify", "config", "track", "reset", "debug", "show", "ping", "page", "hide", "off", "on"],
          t.factory = function (e) {
            return function () {
              var n = Array.prototype.slice.call(arguments);
              return n.unshift(e), t.push(n), t;
            };
          }, t.methods.forEach(function (e) {
            t[e] = t.factory(e);
          }), t.load = function (t) {
            var e = 3e5, n = Math.ceil(new Date() / e) * e, o = document.createElement("script");
            o.type = "text/javascript", o.async = !0, o.crossorigin = "anonymous", o.src = "https://js.driftt.com/include/" + n + "/" + t + ".js";
            var i = document.getElementsByTagName("script")[0];
            i.parentNode.insertBefore(o, i);
          };
      }
    }();
    drift.SNIPPET_VERSION = '0.3.1';
    drift.load('b8zniyzvbfap');
  </script>
  

  <style type="text/css">
    body {
      background-color: #f9f9f9;
    }

    .panel-wrapper {
      box-shadow: 0px 0px 8px rgba(68, 68, 68, .6);
      -moz-box-shadow: 0px 0px 8px rgba(68, 68, 68, .6);
      border-radius: 4px;
      -moz-border-radius: 4px;
      padding: 16px 24px;
      margin-top: 32px;
      background-color: #fff
    }

    .panel-wrapper:hover {
      box-shadow: 0px 0px 12px rgba(68, 68, 68, .6);
      -moz-box-shadow: 0px 0px 12px rgba(68, 68, 68, .6);
    }

    #more {
      margin-top: 16px;
    }

    #copyright {
      padding: 2em 0 0;
      display: block;
      font-size: .9em;
      color: #b3b3b3;
      width: 100%;
      text-align: center
    }

    #list-indicator {
      min-width: 48px;
      text-align: center;
      float: right;
      margin-right: 64px;
      background: rgba(68, 68, 68, .2);
      border-radius: 4px;
      -moz-border-radius: 4px;
      padding: 8px;
    }

    #list-date {
      color: #999;
      font-size: .9em;
      font-style: italic;
    }

    .post-tags-item {
      padding-left: .75rem !important;
      padding-right: .75rem !important;
      padding-top: .25rem !important;
      padding-bottom: .25rem !important;
      margin-right: .5rem !important;
      margin-top: .25rem !important;
      margin-bottom: .25rem !important;
      font-size: .875rem !important;
      color: #666666;
      display: inline-block !important;
      border-radius: .25rem !important;
      background-color: rgb(242 242 247) !important;
    }

    .post-tags-item:hover {
      color: #38b2ac;
    }

    #post-navigator {
      padding: 24px 0px 16px 0px;
      vertical-align: middle;
    }

    #post-navigator>a {
      display: block;
      color: #2479cc;
      text-decoration: none;
    }

    #post-navigator-prev {
      float: left;
    }

    #post-navigator-next {
      float: right;
    }

    .pages {
      text-align: center;
      margin-right: -15px;
      margin-left: -15px;
    }

    .pages>ul {
      font-weight: lighter;
    }

    .pages>.pagination {
      display: inline-block;
      padding-left: 0;
      margin: 20px 0px;
      border-radius: 4px;
    }

    .pages .pagination>li {
      display: inline;
    }

    .pagination>.active>a,
    .pagination>.active>span,
    .pagination>.active>a:hover,
    .pagination>.active>span:hover,
    .pagination>.active>a:focus,
    .pagination>.active>span:focus {
      z-index: 2;
      color: #fff;
      cursor: default;
      background-color: #428bca;
      border-color: #428bca;
    }

    .pagination>li>a,
    .pagination>li>span {
      position: relative;
      float: left;
      padding: 6px 12px;
      margin-left: -1px;
      line-height: 1.428571429;
      text-decoration: none;
      background-color: #fff;
      border: 1px solid #ddd;
    }

    .pagination>li:first-child>a,
    .pagination>li:first-child>span {
      margin-left: 0;
      border-bottom-left-radius: 4px;
      border-top-left-radius: 4px;
    }

    .pagination>.disabled>span,
    .pagination>.disabled>span:hover,
    .pagination>.disabled>span:focus,
    .pagination>.disabled>a,
    .pagination>.disabled>a:hover,
    .pagination>.disabled>a:focus {
      color: #999;
      cursor: not-allowed;
      background-color: #fff;
      border-color: #ddd;
    }

    .pagination>li:last-child>a,
    .pagination>li:last-child>span {
      border-top-right-radius: 4px;
      border-bottom-right-radius: 4px;
    }

    *,
    *:before,
    *:after {
      -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
  </style>
</head>

  <body>
    <div id="scriptHeader">
    <span class="mobile btn-mobile-menu">
            <i class="fa fa-bars btn-mobile-menu__icon"></i>
            <i class="fa fa-times btn-mobile-close__icon hidden"> </i>
    </span>
    <header class="
        
            panel-cover panel-cover--collapsed
        "  style="background-image: url(/images/cover.jpg)" >
    <div class="panel-main">
        <div class="panel-main__inner panel-inverted">
            <div class="panel-main__content"> 
                <a href="https://alimy.github.io/"> <img src="https://alimy.github.io/images/logo.jpg" width="256" alt="北野 logo" class="panel-cover__logo logo" /> </a> 
                <h1 class="panel-cover__title panel-title">
                    <a href="https://alimy.github.io/">北野</a>
                </h1>
                <hr class="panel-cover__divider" />
                <p class="panel-cover__description">  那年江湖，遇见你  </p>
                <hr class="panel-cover__divider panel-cover__divider--secondary" />
                <div class="navigation-wrapper">
                    <nav class="cover-navigation cover-navigation--primary">
                        <ul class="navigation">
                            <li class="navigation__item"><a href="https://alimy.github.io" title="博客首页" class="blog-button">首页</a> </li> </br></br>
                            <li class="navigation__item"><a href="https://alimy.github.io/post/" title="文章列表" class="blog-button">文章列表</a> </li>
                            </br>  </br>
                            <li class="navigation__item"><a href="https://alimy.github.io/pages/cv" title="关于我 " class="blog-button">关于我</a> </li>
                            </br>  </ul>
                            <nav class="cover-navigation navigation--social">
</br>
    <ul class="navigation"> 
        
        <li class="navigation__item">
            <a href="https://iibiubiu.com" title="@iiBiuBiu" target="_blank"> <i class='fa fa-anchor'></i> <span class="label">Twitter</span> </a>
        </li>
        <li class="navigation__item">
            <a href="https://www.paopao.info/#/u?s=alimy" title="@paopao" target="_blank"> <i class='fa fa-leaf'></i> <span class="label">Twitter</span> </a>
        </li><br>
        
        
        
          
        
        <li class="navigation__item">
            <a href="https://github.com/alimy" title="@GitHub" target="_blank"> <i class='fa fa-github'></i> <span class="label">Github</span> </a>
        </li>   </br>    </ul>
</nav>

                    </nav>  </div>
            </div>
        </div>
        <div class="panel-cover--overlay"></div>
    </div>
</header>
</div>
<noscript>
    <style>
        #scriptHeader {display:none;}
        .navigation-wrapper{
            display: block;
            top: 0;
        }
    </style>

    <header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/cover.jpg)">
        <div class="panel-main">
            <div class="panel-main__inner panel-inverted">
                <div class="panel-main__content"> 
                    <a href="https://alimy.github.io/"> <img src="https://alimy.github.io/images/logo.jpg" width="80" alt="北野 logo" class="panel-cover__logo logo" /> </a> 
                    <h1 class="panel-cover__title panel-title">
                        <a href="https://alimy.github.io/">北野</a>
                    </h1>
                    <hr class="panel-cover__divider" />
                    <p class="panel-cover__description">  那年江湖，遇见你  </p>
                    <hr class="panel-cover__divider panel-cover__divider--secondary" />
                    <div class="navigation-wrapper">
                        <nav class="cover-navigation cover-navigation--primary">
                            <ul class="navigation">
                                <li class="navigation__item"><a href="https://alimy.github.io" title="博客首页" class="blog-button">Blog</a> </li></br></br>
                                <li class="navigation__item"><a href="https://alimy.github.io/post/" title="文章列表" class="blog-button">Articles</a> </li>
                                </br>  </br>
                                <li class="navigation__item"><a href="https://alimy.github.io/pages/cv" title="关于我 " class="blog-button">About Me</a> </li>
                                </br>  </ul>
                        </nav> <nav class="cover-navigation navigation--social">
</br>
    <ul class="navigation"> 
        
        <li class="navigation__item">
            <a href="https://iibiubiu.com" title="@iiBiuBiu" target="_blank"> <i class='fa fa-anchor'></i> <span class="label">Twitter</span> </a>
        </li>
        <li class="navigation__item">
            <a href="https://www.paopao.info/#/u?s=alimy" title="@paopao" target="_blank"> <i class='fa fa-leaf'></i> <span class="label">Twitter</span> </a>
        </li><br>
        
        
        
          
        
        <li class="navigation__item">
            <a href="https://github.com/alimy" title="@GitHub" target="_blank"> <i class='fa fa-github'></i> <span class="label">Github</span> </a>
        </li>   </br>    </ul>
</nav>
 </div>
                </div>
            </div>
            <div class="panel-cover--overlay"></div>
        </div>
    </header>
</noscript>

    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <div class="post panel-wrapper">
            <h2>Go - EBNF</h2>
          
          <h3 id="notation">Notation</h3>
<p>The syntax is specified using Extended Backus-Naur Form (EBNF):</p>
<pre tabindex="0"><code>Production  = production_name &#34;=&#34; [ Expression ] &#34;.&#34; .
Expression  = Alternative { &#34;|&#34; Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ &#34;…&#34; token ] | Group | Option | Repetition .
Group       = &#34;(&#34; Expression &#34;)&#34; .
Option      = &#34;[&#34; Expression &#34;]&#34; .
Repetition  = &#34;{&#34; Expression &#34;}&#34; .
</code></pre><p>Productions are expressions constructed from terms and the following operators, in increasing precedence:</p>
<pre tabindex="0"><code>|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
</code></pre><p>Lower-case production names are used to identify lexical tokens. Non-terminals are in CamelCase. Lexical tokens are enclosed in double quotes &quot;&quot; or back quotes ``.</p>
<p>The form a … b represents the set of characters from a through b as alternatives. The horizontal ellipsis … is also used elsewhere in the spec to informally denote various enumerations or code snippets that are not further specified. The character … (as opposed to the three characters &hellip;) is not a token of the Go language.</p>
<h3 id="go-ebnf">Go EBNF</h3>
<ul>
<li>
<p>Characters</p>
<pre tabindex="0"><code>newline        = /* the Unicode code point U+000A */ .
unicode_char   = /* an arbitrary Unicode code point except newline */ .
unicode_letter = /* a Unicode code point classified as &#34;Letter&#34; */ .
unicode_digit  = /* a Unicode code point classified as &#34;Number, decimal digit&#34; */ .
</code></pre></li>
<li>
<p>Letters and digits</p>
<pre tabindex="0"><code>letter        = unicode_letter | &#34;_&#34; .
decimal_digit = &#34;0&#34; … &#34;9&#34; .
octal_digit   = &#34;0&#34; … &#34;7&#34; .
hex_digit     = &#34;0&#34; … &#34;9&#34; | &#34;A&#34; … &#34;F&#34; | &#34;a&#34; … &#34;f&#34; .
</code></pre></li>
<li>
<p>Identifiers</p>
<pre tabindex="0"><code>identifier = letter { letter | unicode_digit } .
</code></pre></li>
<li>
<p>Keywords</p>
<pre tabindex="0"><code>break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
</code></pre></li>
<li>
<p>Operators and Delimiters</p>
<pre tabindex="0"><code>&amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )	   +
|     -=    |=     ||    &lt;     &lt;=    [    ]	   -
^     *=    ^=     &lt;-    &gt;     &gt;=    {    }    *
/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;
%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :
	 &amp;^          &amp;^=
</code></pre></li>
<li>
<p>Integer literals</p>
<pre tabindex="0"><code>int_lit     = decimal_lit | octal_lit | hex_lit .
decimal_lit = ( &#34;1&#34; … &#34;9&#34; ) { decimal_digit } .
octal_lit   = &#34;0&#34; { octal_digit } .
hex_lit     = &#34;0&#34; ( &#34;x&#34; | &#34;X&#34; ) hex_digit { hex_digit } .
</code></pre></li>
<li>
<p>Floating-point literals</p>
<pre tabindex="0"><code>float_lit = decimals &#34;.&#34; [ decimals ] [ exponent ] |
	        decimals exponent |
    	    &#34;.&#34; decimals [ exponent ] .
decimals  = decimal_digit { decimal_digit } .
exponent  = ( &#34;e&#34; | &#34;E&#34; ) [ &#34;+&#34; | &#34;-&#34; ] decimals .
</code></pre></li>
<li>
<p>Imaginary literals</p>
<pre tabindex="0"><code>imaginary_lit = (decimals | float_lit) &#34;i&#34; .
</code></pre></li>
<li>
<p>Rune literals</p>
<pre tabindex="0"><code>\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\\   U+005c backslash
\&#39;   U+0027 single quote  (valid escape only within rune literals)
\&#34;   U+0022 double quote  (valid escape only within string literals)
</code></pre><pre tabindex="0"><code>rune_lit         = &#34;&#39;&#34; ( unicode_value | byte_value ) &#34;&#39;&#34; .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` &#34;x&#34; hex_digit hex_digit .
little_u_value   = `\` &#34;u&#34; hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` &#34;U&#34; hex_digit hex_digit hex_digit hex_digit
	                       hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( &#34;a&#34; | &#34;b&#34; | &#34;f&#34; | &#34;n&#34; | &#34;r&#34; | &#34;t&#34; | &#34;v&#34; | `\` | &#34;&#39;&#34; | `&#34;` ) .
</code></pre></li>
<li>
<p>String literals</p>
<pre tabindex="0"><code>string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = &#34;`&#34; { unicode_char | newline } &#34;`&#34; .
interpreted_string_lit = `&#34;` { unicode_value | byte_value } `&#34;` .
</code></pre></li>
<li>
<p>Types</p>
<pre tabindex="0"><code>Type      = TypeName | TypeLit | &#34;(&#34; Type &#34;)&#34; .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
		    SliceType | MapType | ChannelType .
</code></pre></li>
<li>
<p>Numeric types</p>
<pre tabindex="0"><code>uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for uint8
rune        alias for int32

uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
</code></pre></li>
<li>
<p>Array types</p>
<pre tabindex="0"><code>ArrayType   = &#34;[&#34; ArrayLength &#34;]&#34; ElementType .
ArrayLength = Expression .
ElementType = Type .
</code></pre></li>
<li>
<p>Slice types</p>
<pre tabindex="0"><code>SliceType = &#34;[&#34; &#34;]&#34; ElementType .
</code></pre><pre tabindex="0"><code>make([]T, length, capacity)
make([]int, 50, 100)
new([100]int)[0:50]
</code></pre></li>
<li>
<p>Struct types</p>
<pre tabindex="0"><code>StructType     = &#34;struct&#34; &#34;{&#34; { FieldDecl &#34;;&#34; } &#34;}&#34; .
FieldDecl      = (IdentifierList Type | AnonymousField) [ Tag ] .
AnonymousField = [ &#34;*&#34; ] TypeName .
Tag            = string_lit .
</code></pre></li>
<li>
<p>Pointer types</p>
<pre tabindex="0"><code>PointerType = &#34;*&#34; BaseType .
BaseType    = Type .
</code></pre></li>
<li>
<p>Function types</p>
<pre tabindex="0"><code>FunctionType   = &#34;func&#34; Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = &#34;(&#34; [ ParameterList [ &#34;,&#34; ] ] &#34;)&#34; .
ParameterList  = ParameterDecl { &#34;,&#34; ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ &#34;...&#34; ] Type .
</code></pre></li>
<li>
<p>Interface types</p>
<pre tabindex="0"><code>InterfaceType      = &#34;interface&#34; &#34;{&#34; { MethodSpec &#34;;&#34; } &#34;}&#34; .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
</code></pre></li>
<li>
<p>Map types</p>
<pre tabindex="0"><code>MapType     = &#34;map&#34; &#34;[&#34; KeyType &#34;]&#34; ElementType .
KeyType     = Type .
</code></pre></li>
<li>
<p>Channel types</p>
<pre tabindex="0"><code>ChannelType = ( &#34;chan&#34; | &#34;chan&#34; &#34;&lt;-&#34; | &#34;&lt;-&#34; &#34;chan&#34; ) ElementType .
</code></pre><pre tabindex="0"><code>chan T          // can be used to send and receive values of type T
chan&lt;- float64  // can only be used to send float64s
&lt;-chan int      // can only be used to receive ints

chan&lt;- chan int    // same as chan&lt;- (chan int)
chan&lt;- &lt;-chan int  // same as chan&lt;- (&lt;-chan int)
&lt;-chan &lt;-chan int  // same as &lt;-chan (&lt;-chan int)
chan (&lt;-chan int)

make(chan int, 100)
</code></pre></li>
<li>
<p>Type identity</p>
<p>Two types are either identical or different.</p>
<p>Two named types are identical if their type names originate in the same TypeSpec. A named and an unnamed type are always different. Two unnamed types are identical if the corresponding type literals are identical, that is, if they have the same literal structure and corresponding components have identical types. In detail:</p>
<ol>
<li>Two <strong>array</strong> types are identical if they have identical element types and the same array length.</li>
<li>Two <strong>slice</strong> types are identical if they have identical element types.</li>
<li>Two <strong>struct</strong> types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags. Two anonymous fields are considered to have the same name. Lower-case field names from different packages are always different.</li>
<li>Two <strong>pointer</strong> types are identical if they have identical base types.</li>
<li>Two <strong>function</strong> types are identical if they have the same <em>number of parameters and result values, corresponding parameter and result types</em> are identical, and either both functions are variadic or neither is. Parameter and result names are not required to match.</li>
<li>Two <strong>interface</strong> types are identical if they have the same set of methods with the same names and identical function types. Lower-case method names from different packages are always different. The order of the methods is irrelevant.</li>
<li>Two <strong>map</strong> types are identical if they have identical key and value types.</li>
<li>Two <strong>channel</strong> types are identical if they have identical value types and the same direction.</li>
</ol>
</li>
<li>
<p>Assignability</p>
<p>A value x is assignable to a variable of type T (&ldquo;x is assignable to T&rdquo;) in any of these cases:</p>
<ol>
<li>x&rsquo;s type is identical to T.</li>
<li>x&rsquo;s type V and T have identical underlying types and at least one of V or T is not a named type.</li>
<li>T is an interface type and x implements T.</li>
<li>x is a bidirectional channel value, T is a channel type, x&rsquo;s type V and T have identical element types, and at least one of V or T is not a named type.</li>
<li>x is the predeclared identifier nil and T is a pointer, function, slice, map, channel, or interface type.</li>
<li>x is an untyped constant representable by a value of type T.</li>
</ol>
</li>
<li>
<p>Blocks</p>
<pre tabindex="0"><code>Block = &#34;{&#34; StatementList &#34;}&#34; .
StatementList = { Statement &#34;;&#34; } .
</code></pre></li>
<li>
<p>Declarations and scope</p>
<pre tabindex="0"><code>Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
</code></pre></li>
<li>
<p>Predeclared identifiers</p>
<pre tabindex="0"><code>Types:
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

Constants:
	true false iota

Zero value:
	nil

Functions:
	append cap close complex copy delete imag len
	make new panic print println real recover
</code></pre></li>
<li>
<p>Exported identifiers</p>
<p>An identifier may be exported to permit access to it from another package. An identifier is exported if both:</p>
<ol>
<li>the first character of the identifier&rsquo;s name is a Unicode upper case letter (Unicode class &ldquo;Lu&rdquo;); and</li>
<li>the identifier is declared in the package block or it is a field name or method name.
All other identifiers are not exported.</li>
</ol>
</li>
<li>
<p>Uniqueness of identifiers</p>
<p>Given a set of identifiers, an identifier is called unique if it is different from every other in the set. Two identifiers are different if they are spelled differently, or if they appear in different packages and are not exported. Otherwise, they are the same.</p>
</li>
<li>
<p>Constant declarations</p>
<pre tabindex="0"><code>ConstDecl      = &#34;const&#34; ( ConstSpec | &#34;(&#34; { ConstSpec &#34;;&#34; } &#34;)&#34; ) .
ConstSpec      = IdentifierList [ [ Type ] &#34;=&#34; ExpressionList ] .

IdentifierList = identifier { &#34;,&#34; identifier } .
ExpressionList = Expression { &#34;,&#34; Expression } .
</code></pre></li>
<li>
<p>Iota
Within a constant declaration, the predeclared identifier iota represents successive untyped integer constants. It is reset to 0 whenever the reserved word const appears in the source and increments after each ConstSpec. It can be used to construct a set of related constants:</p>
<pre tabindex="0"><code>const ( // iota is reset to 0
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const ( // iota is reset to 0
	a = 1 &lt;&lt; iota  // a == 1
	b = 1 &lt;&lt; iota  // b == 2
	c = 3          // c == 3  (iota is not used but still incremented)
	d = 1 &lt;&lt; iota  // d == 8
)

const ( // iota is reset to 0
	u         = iota * 42  // u == 0     (untyped integer constant)
	v float64 = iota * 42  // v == 42.0  (float64 constant)
	w         = iota * 42  // w == 84    (untyped integer constant)
)

const x = iota  // x == 0  (iota has been reset)
const y = iota  // y == 0  (iota has been reset)

const (
	bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1  // bit0 == 1, mask0 == 0
	bit1, mask1                           // bit1 == 2, mask1 == 1
	_, _                                  // skips iota == 2
	bit3, mask3                           // bit3 == 8, mask3 == 7
)
</code></pre></li>
<li>
<p>Type declarations</p>
<pre tabindex="0"><code>TypeDecl     = &#34;type&#34; ( TypeSpec | &#34;(&#34; { TypeSpec &#34;;&#34; } &#34;)&#34; ) .
TypeSpec     = identifier Type .
</code></pre><pre tabindex="0"><code>type IntArray [16]int

type (
	Point struct{ x, y float64 }
	Polar Point
)

type TreeNode struct {
	left, right *TreeNode
	value *Comparable
}

type Block interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
</code></pre><p>The declared type does not inherit any methods bound to the existing type, but the method set of an interface type or of elements of a composite type remains unchanged:</p>
<pre tabindex="0"><code>// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock implementation */ }
func (m *Mutex) Unlock()  { /* Unlock implementation */ }

// NewMutex has the same composition as Mutex but its method set is empty.
type NewMutex Mutex

// The method set of the base type of PtrMutex remains unchanged,
// but the method set of PtrMutex is empty.
type PtrMutex *Mutex

// The method set of *PrintableMutex contains the methods
// Lock and Unlock bound to its anonymous field Mutex.
type PrintableMutex struct {
	Mutex
}

// MyBlock is an interface type that has the same method set as Block.
type MyBlock Block
</code></pre><p>A type declaration may be used to define a different boolean, numeric, or string type and attach methods to it:</p>
<pre tabindex="0"><code>type TimeZone int

const (
	EST TimeZone = -(5 + iota)
	CST
	MST
	PST
)

func (tz TimeZone) String() string {
	return fmt.Sprintf(&#34;GMT%+dh&#34;, tz)
}
</code></pre></li>
<li>
<p>Variable declarations</p>
<pre tabindex="0"><code>VarDecl     = &#34;var&#34; ( VarSpec | &#34;(&#34; { VarSpec &#34;;&#34; } &#34;)&#34; ) .
VarSpec     = IdentifierList ( Type [ &#34;=&#34; ExpressionList ] | &#34;=&#34; ExpressionList ) .
</code></pre></li>
<li>
<p>Short variable declarations</p>
<pre tabindex="0"><code>ShortVarDecl = IdentifierList &#34;:=&#34; ExpressionList .
</code></pre><p>It is shorthand for a regular variable declaration with initializer expressions but no types:</p>
<pre tabindex="0"><code>&#34;var&#34; IdentifierList = ExpressionList .
</code></pre><pre tabindex="0"><code>i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w := os.Pipe(fd)  // os.Pipe() returns two values
_, y, _ := coord(p)  // coord() returns three values; only interested in y coordinate
</code></pre><p>Unlike regular variable declarations, a short variable declaration may redeclare variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and at least one of the non-blank variables is new. As a consequence, redeclaration can only appear in a multi-variable short declaration. Redeclaration does not introduce a new variable; it just assigns a new value to the original.</p>
<pre tabindex="0"><code>field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // redeclares offset
a, a := 1, 2       // illegal: double declaration of a or no new variable if a was declared elsewhere
</code></pre><p>Short variable declarations may appear only inside functions. In some contexts such as the initializers for &ldquo;if&rdquo;, &ldquo;for&rdquo;, or &ldquo;switch&rdquo; statements, they can be used to declare local temporary variables.</p>
</li>
<li>
<p>Function declarations</p>
<pre tabindex="0"><code>FunctionDecl = &#34;func&#34; FunctionName ( Function | Signature ) .
FunctionName = identifier .
Function     = Signature FunctionBody .
FunctionBody = Block .
</code></pre></li>
<li>
<p>Method declarations</p>
<pre tabindex="0"><code>MethodDecl   = &#34;func&#34; Receiver MethodName ( Function | Signature ) .
Receiver     = Parameters .
</code></pre></li>
<li>
<p>Operands</p>
<pre tabindex="0"><code>Operand     = Literal | OperandName | MethodExpr | &#34;(&#34; Expression &#34;)&#34; .
Literal     = BasicLit | CompositeLit | FunctionLit .
BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
OperandName = identifier | QualifiedIdent.
</code></pre></li>
<li>
<p>Qualified identifiers</p>
<pre tabindex="0"><code>QualifiedIdent = PackageName &#34;.&#34; identifier .
</code></pre></li>
<li>
<p>Composite literals</p>
<pre tabindex="0"><code>CompositeLit  = LiteralType LiteralValue .
LiteralType   = StructType | ArrayType | &#34;[&#34; &#34;...&#34; &#34;]&#34; ElementType |
	            SliceType | MapType | TypeName .
LiteralValue  = &#34;{&#34; [ ElementList [ &#34;,&#34; ] ] &#34;}&#34; .
ElementList   = KeyedElement { &#34;,&#34; KeyedElement } .
KeyedElement  = [ Key &#34;:&#34; ] Element .
Key           = FieldName | Expression | LiteralValue .
FieldName     = identifier .
Element       = Expression | LiteralValue .
</code></pre></li>
<li>
<p>Function literals</p>
<pre tabindex="0"><code>FunctionLit = &#34;func&#34; Function .
</code></pre></li>
<li>
<p>Primary expressions</p>
<pre tabindex="0"><code>PrimaryExpr =
	Operand |
	Conversion |
	PrimaryExpr Selector |
	PrimaryExpr Index |
	PrimaryExpr Slice |
	PrimaryExpr TypeAssertion |
	PrimaryExpr Arguments .

Selector       = &#34;.&#34; identifier .
Index          = &#34;[&#34; Expression &#34;]&#34; .
Slice          = &#34;[&#34; ( [ Expression ] &#34;:&#34; [ Expression ] ) |
                  ( [ Expression ] &#34;:&#34; Expression &#34;:&#34; Expression )
	             &#34;]&#34; .
TypeAssertion  = &#34;.&#34; &#34;(&#34; Type &#34;)&#34; .
Arguments      = &#34;(&#34; [ ( ExpressionList | Type [ &#34;,&#34; ExpressionList ] ) [ &#34;...&#34; ] [ &#34;,&#34; ] ] &#34;)&#34; .
</code></pre></li>
<li>
<p>Selectors</p>
<p>For a primary expression x that is not a package name, the selector expression</p>
<pre tabindex="0"><code>x.f
</code></pre><p>denotes the field or method f of the value x (or sometimes *x; see below). The identifier f is called the (field or method) selector; it must not be the blank identifier. The type of the selector expression is the type of f. If x is a package name, see the section on qualified identifiers.</p>
<p>A selector f may denote a field or method f of a type T, or it may refer to a field or method f of a nested anonymous field of T. The number of anonymous fields traversed to reach f is called its depth in T. The depth of a field or method f declared in T is zero. The depth of a field or method f declared in an anonymous field A in T is the depth of f in A plus one.</p>
<p>The following rules apply to selectors:</p>
<ol>
<li>For a value x of type T or *T where T is not a pointer or interface type, x.f denotes the field or method at the shallowest depth in T where there is such an f. If there is not exactly one f with shallowest depth, the selector expression is illegal.</li>
<li>For a value x of type I where I is an interface type, x.f denotes the actual method with name f of the dynamic value of x. If there is no method with name f in the method set of I, the selector expression is illegal.</li>
<li>As an exception, if the type of x is a named pointer type and (*x).f is a valid selector expression denoting a field (but not a method), x.f is shorthand for (*x).f.</li>
<li>In all other cases, x.f is illegal.</li>
<li>If x is of pointer type and has the value nil and x.f denotes a struct field, assigning to or evaluating x.f causes a run-time panic.</li>
<li>If x is of interface type and has the value nil, calling or evaluating the method x.f causes a run-time panic.</li>
</ol>
</li>
<li>
<p>Method expressions</p>
<pre tabindex="0"><code>MethodExpr    = ReceiverType &#34;.&#34; MethodName .
ReceiverType  = TypeName | &#34;(&#34; &#34;*&#34; TypeName &#34;)&#34; | &#34;(&#34; ReceiverType &#34;)&#34; .
</code></pre></li>
<li>
<p>Index expressions</p>
<pre tabindex="0"><code>a[x]
</code></pre></li>
<li>
<p>Slice expressions</p>
<pre tabindex="0"><code>a[low : high]

a[low : high : max]
</code></pre></li>
<li>
<p>Type assertions</p>
<pre tabindex="0"><code>x.(T)
</code></pre></li>
<li>
<p>Calls</p>
<pre tabindex="0"><code>f(a1, a2, … an)
</code></pre></li>
<li>
<p>Passing arguments to &hellip; parameters</p>
<p>Given the function and calls</p>
<pre tabindex="0"><code>func Greeting(prefix string, who ...string)
Greeting(&#34;nobody&#34;)
Greeting(&#34;hello:&#34;, &#34;Joe&#34;, &#34;Anna&#34;, &#34;Eileen&#34;)
</code></pre><p>Given the slice s and call</p>
<pre tabindex="0"><code>s := []string{&#34;James&#34;, &#34;Jasmine&#34;}
Greeting(&#34;goodbye:&#34;, s...)
</code></pre></li>
<li>
<p>Operators</p>
<pre tabindex="0"><code>Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = &#34;||&#34; | &#34;&amp;&amp;&#34; | rel_op | add_op | mul_op .
rel_op     = &#34;==&#34; | &#34;!=&#34; | &#34;&lt;&#34; | &#34;&lt;=&#34; | &#34;&gt;&#34; | &#34;&gt;=&#34; .
add_op     = &#34;+&#34; | &#34;-&#34; | &#34;|&#34; | &#34;^&#34; .
mul_op     = &#34;*&#34; | &#34;/&#34; | &#34;%&#34; | &#34;&lt;&lt;&#34; | &#34;&gt;&gt;&#34; | &#34;&amp;&#34; | &#34;&amp;^&#34; .

unary_op   = &#34;+&#34; | &#34;-&#34; | &#34;!&#34; | &#34;^&#34; | &#34;*&#34; | &#34;&amp;&#34; | &#34;&lt;-&#34; .
</code></pre></li>
<li>
<p>Operator precedence</p>
<pre tabindex="0"><code>Precedence    Operator
5             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^
4             +  -  |  ^
3             ==  !=  &lt;  &lt;=  &gt;  &gt;=
2             &amp;&amp;
1             ||
</code></pre></li>
<li>
<p>Arithmetic operators</p>
<pre tabindex="0"><code>+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
*    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers

&amp;    bitwise AND            integers
|    bitwise OR             integers
^    bitwise XOR            integers
&amp;^   bit clear (AND NOT)    integers

&lt;&lt;   left shift             integer &lt;&lt; unsigned integer
&gt;&gt;   right shift            integer &gt;&gt; unsigned integer
</code></pre></li>
<li>
<p>Comparison operators</p>
<pre tabindex="0"><code>==    equal
!=    not equal
&lt;     less
&lt;=    less or equal
&gt;     greater
&gt;=    greater or equal
</code></pre></li>
<li>
<p>Logical operators</p>
<pre tabindex="0"><code>&amp;&amp;    conditional AND    p &amp;&amp; q  is  &#34;if p then q else false&#34;
||    conditional OR     p || q  is  &#34;if p then true else q&#34;
!     NOT                !p      is  &#34;not p&#34;
</code></pre></li>
<li>
<p>Address operators</p>
<pre tabindex="0"><code>&amp;x
&amp;a[f(2)]
&amp;Point{2, 3}
*p
*pf(x)

var x *int = nil
*x   // causes a run-time panic
&amp;*x  // causes a run-time panic
</code></pre></li>
<li>
<p>Receive operator</p>
<pre tabindex="0"><code>v1 := &lt;-ch
v2 = &lt;-ch
f(&lt;-ch)
&lt;-strobe  // wait until clock pulse and discard received value

x, ok = &lt;-ch
x, ok := &lt;-ch
var x, ok = &lt;-ch
</code></pre></li>
<li>
<p>Conversions</p>
<pre tabindex="0"><code>Conversion = Type &#34;(&#34; Expression [ &#34;,&#34; ] &#34;)&#34; .
</code></pre></li>
<li>
<p>Statements</p>
<pre tabindex="0"><code>Statement =
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
</code></pre></li>
<li>
<p>Empty statements</p>
<pre tabindex="0"><code>EmptyStmt = .
</code></pre></li>
<li>
<p>Labeled statements</p>
<pre tabindex="0"><code>LabeledStmt = Label &#34;:&#34; Statement .
Label       = identifier .
</code></pre></li>
<li>
<p>Expression statements</p>
<pre tabindex="0"><code>ExpressionStmt = Expression .
</code></pre><p>The following built-in functions are not permitted in statement context:</p>
<pre tabindex="0"><code>append cap complex imag len make new real
unsafe.Alignof unsafe.Offsetof unsafe.Sizeof
</code></pre></li>
<li>
<p>Send statements</p>
<pre tabindex="0"><code>SendStmt = Channel &#34;&lt;-&#34; Expression .
Channel  = Expression .
</code></pre></li>
<li>
<p>IncDec statements</p>
<pre tabindex="0"><code>IncDecStmt = Expression ( &#34;++&#34; | &#34;--&#34; ) .
</code></pre></li>
<li>
<p>Assignments</p>
<pre tabindex="0"><code>Assignment = ExpressionList assign_op ExpressionList .

assign_op = [ add_op | mul_op ] &#34;=&#34; .
</code></pre></li>
<li>
<p>If statements</p>
<pre tabindex="0"><code>IfStmt = &#34;if&#34; [ SimpleStmt &#34;;&#34; ] Expression Block [ &#34;else&#34; ( IfStmt | Block ) ] .
</code></pre></li>
<li>
<p>Switch statements</p>
<pre tabindex="0"><code>SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
</code></pre></li>
<li>
<p>Expression switches</p>
<pre tabindex="0"><code>ExprSwitchStmt = &#34;switch&#34; [ SimpleStmt &#34;;&#34; ] [ Expression ] &#34;{&#34; { ExprCaseClause } &#34;}&#34; .
ExprCaseClause = ExprSwitchCase &#34;:&#34; StatementList .
ExprSwitchCase = &#34;case&#34; ExpressionList | &#34;default&#34; .
</code></pre></li>
<li>
<p>Type switches</p>
<pre tabindex="0"><code>switch x.(type) {
// cases
}
</code></pre><pre tabindex="0"><code>TypeSwitchStmt  = &#34;switch&#34; [ SimpleStmt &#34;;&#34; ] TypeSwitchGuard &#34;{&#34; { TypeCaseClause } &#34;}&#34; .
TypeSwitchGuard = [ identifier &#34;:=&#34; ] PrimaryExpr &#34;.&#34; &#34;(&#34; &#34;type&#34; &#34;)&#34; .
TypeCaseClause  = TypeSwitchCase &#34;:&#34; StatementList .
TypeSwitchCase  = &#34;case&#34; TypeList | &#34;default&#34; .
TypeList        = Type { &#34;,&#34; Type } .
</code></pre></li>
<li>
<p>For statements</p>
<pre tabindex="0"><code>ForStmt = &#34;for&#34; [ Condition | ForClause | RangeClause ] Block .
Condition = Expression .
</code></pre><pre tabindex="0"><code>ForClause = [ InitStmt ] &#34;;&#34; [ Condition ] &#34;;&#34; [ PostStmt ] .
InitStmt = SimpleStmt .
PostStmt = SimpleStmt .
</code></pre><pre tabindex="0"><code>RangeClause = [ ExpressionList &#34;=&#34; | IdentifierList &#34;:=&#34; ] &#34;range&#34; Expression .
</code></pre><pre tabindex="0"><code>Range expression                          1st value          2nd value

array or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E
string          s  string type            index    i  int    see below  rune
map             m  map[K]V                key      k  K      m[k]       V
channel         c  chan E, &lt;-chan E       element  e  E
</code></pre></li>
<li>
<p>Go statements</p>
<pre tabindex="0"><code>GoStmt = &#34;go&#34; Expression .
</code></pre></li>
<li>
<p>Select statements</p>
<pre tabindex="0"><code>SelectStmt = &#34;select&#34; &#34;{&#34; { CommClause } &#34;}&#34; .
CommClause = CommCase &#34;:&#34; StatementList .
CommCase   = &#34;case&#34; ( SendStmt | RecvStmt ) | &#34;default&#34; .
RecvStmt   = [ ExpressionList &#34;=&#34; | IdentifierList &#34;:=&#34; ] RecvExpr .
RecvExpr   = Expression .
</code></pre></li>
<li>
<p>Return statements</p>
<pre tabindex="0"><code>ReturnStmt = &#34;return&#34; [ ExpressionList ] .
</code></pre></li>
<li>
<p>Break statements</p>
<pre tabindex="0"><code>BreakStmt = &#34;break&#34; [ Label ] .
</code></pre></li>
<li>
<p>Continue statements</p>
<pre tabindex="0"><code>ContinueStmt = &#34;continue&#34; [ Label ] .
</code></pre></li>
<li>
<p>Goto statements</p>
<pre tabindex="0"><code>GotoStmt = &#34;goto&#34; Label .
</code></pre></li>
<li>
<p>Fallthrough statements</p>
<pre tabindex="0"><code>FallthroughStmt = &#34;fallthrough&#34; .
</code></pre></li>
<li>
<p>Defer statements</p>
<pre tabindex="0"><code>DeferStmt = &#34;defer&#34; Expression .
</code></pre></li>
<li>
<p>Source file organization</p>
<pre tabindex="0"><code>SourceFile       = PackageClause &#34;;&#34; { ImportDecl &#34;;&#34; } { TopLevelDecl &#34;;&#34; } .
</code></pre></li>
<li>
<p>Package clause</p>
<pre tabindex="0"><code>PackageClause  = &#34;package&#34; PackageName .
PackageName    = identifier .
</code></pre></li>
<li>
<p>Import declarations</p>
<pre tabindex="0"><code>ImportDecl       = &#34;import&#34; ( ImportSpec | &#34;(&#34; { ImportSpec &#34;;&#34; } &#34;)&#34; ) .
ImportSpec       = [ &#34;.&#34; | PackageName ] ImportPath .
ImportPath       = string_lit .
</code></pre><pre tabindex="0"><code>Import declaration          Local name of Sin

import   &#34;lib/math&#34;         math.Sin
import m &#34;lib/math&#34;         m.Sin
import . &#34;lib/math&#34;         Sin

import _ &#34;lib/math&#34;
</code></pre></li>
<li>
<p>Size and alignment guarantees</p>
<p>For the numeric types, the following sizes are guaranteed:</p>
<pre tabindex="0"><code>type                                 size in bytes

byte, uint8, int8                     1
uint16, int16                         2
uint32, int32, float32                4
uint64, int64, float64, complex64     8
complex128                           16
</code></pre><p>The following minimal alignment properties are guaranteed:</p>
<ul>
<li>For a variable x of any type: unsafe.Alignof(x) is at least 1.</li>
<li>For a variable x of struct type: unsafe.Alignof(x) is the largest of all the values unsafe.Alignof(x.f) for each field f of x, but at least 1.</li>
<li>For a variable x of array type: unsafe.Alignof(x) is the same as unsafe.Alignof(x[0]), but at least 1.</li>
</ul>
<p>A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.</p>
</li>
</ul>
<hr>
<p>(Note: The Go Programming Language Specification is <a href="https://golang.org/ref/spec" title="The Go Programming Language Specification"><em>here</em></a> )</p>
				<div id="post-tags">
				  
				  	
						  <a href="https://alimy.github.io/tags/development/" class="post-tags-item"><i class="fa fa-tag" aria-hidden="true"></i>&nbsp;development</a>
						
						  <a href="https://alimy.github.io/tags/golang/" class="post-tags-item"><i class="fa fa-tag" aria-hidden="true"></i>&nbsp;Golang</a>
						
					
				</div>
        </div>
        <div id="post-navigator">
          <a id="post-navigator-prev" href="https://alimy.github.io/post/dev_201603242255/" title="上一篇"><i class="fa fa-chevron-left" aria-hidden="true"></i>&nbsp;Makefile:简介</a>
          <a id="post-navigator-next" href="https://alimy.github.io/post/art_201604091521/" title="下一篇">爱&nbsp;<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
        </div>
        <div id="post-comments">
          <h3>Comments</h3>
          


<div id="disqus_thread"></div>

<script type="text/javascript">
  var disqusUsername = "alimy";

  (function() { 
  var d = document, s = d.createElement('script');

  s.src = '//' + disqusUsername + '.disqus.com/embed.js';

  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


        </div>
        <footer id="copyright">
  <p>&copy;2015-至今 <a href="mailto:alimy@niubiu.com" title="Email:alimy@niubiu.com">北野 -  Michael Li</a> All rights reserved.</p>
</footer>

    </div>
    <script>(function(){var WebP=new Image();WebP.onload=WebP.onerror=function(){
if(WebP.height!=2){var sc=document.createElement('script');sc.type='text/javascript';sc.async=true;
var s=document.getElementsByTagName('script')[0];sc.src='https://alimy.github.io/js/webpjs-0.0.2.min.js';s.parentNode.insertBefore(sc,s);}};
WebP.src='data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';})();</script>

  </body>
</html>
