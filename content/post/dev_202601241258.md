+++

title = "TL在Go如何实现oneof语义"
tags = [
    "development",
    "Go",   
	"RPC", 
	"TL", 
	"tg", 
]
date = "2026-01-24T12:58:00+08:00"
categories = [
    "Development",
]
menu = "Development"

+++

TL的Type是一个总类型`Class`包含不同的结构子类型实例`Object`，类似于Protubuf中`Message`与`Oneof`的关系。
#### Telegram的RPC TL片段1：
```tl
peerUser#9db1bc6d user_id:int = Peer;
peerChat#bad0e5bb chat_id:int = Peer;
peerChannel#bddde532 channel_id:int = Peer;

folderPeer#e9baa668 peer:Peer folder_id:int = FolderPeer;
```
<!--more-->  
#### 上述TL片段1 等价的Protobuf描述：
```proto
syntax = "proto3";

package tg_oneof;

option go_package = "./tg_oneof";


message Peer {
	message PeerUser {
		int32 user_id = 1;  
	}
	message PeerChat {
		int32 chat_id = 1;
	}
	message PeerChannel {
	    int32 channel_id = 1;
	}
  
  oneof oneofPeer {
    PeerUser peerUser = 1;
    PeerChat peerChat = 2;
    PeerChannel peerChannel = 3;
  }
}

message FolderPeer {
	message FolderPeer {
		oneof oneofPeer {
			Peer.PeerUser peerUser = 1;
			Peer.PeerChat peerChat = 2;
			Peer.PeerChannel peerChannel = 3;
		}
		int32 folder_id = 1;
	}
}
```

#### [gotd](https://github.com/gotd/td)生成的代码：
```go
// PeerClass represents Peer generic type.
//
// Constructors:
// - [PeerUser]
// - [PeerChat]
// - [PeerChannel]
//
// Example:
//
// g, err := tg.DecodePeer(buf)
// if err != nil {
//     panic(err)
// }
// switch v := g.(type) {
// case *tg.PeerUser: // peerUser#59511722
// case *tg.PeerChat: // peerChat#36c6019a
// case *tg.PeerChannel: // peerChannel#a2a5371e
// default: panic(v)
// }
type PeerClass interface {
    bin.Encoder
    bin.Decoder
    bin.BareEncoder
    bin.BareDecoder
    construct() PeerClass

    // TypeID returns type id in TL schema.
    TypeID() uint32
    // TypeName returns name of type in TL schema.
    TypeName() string
    // String implements fmt.Stringer.
    String() string
    // Zero returns true if current object has a zero value.
    Zero() bool
}

// PeerChannel represents TL type `peerChannel#a2a5371e`.
// Channel/supergroup
type PeerChannel struct {
    // Channel ID
    ChannelID int64
}

// construct implements constructor of PeerClass.
func (p PeerChannel) construct() PeerClass { return &p }

// PeerChat represents TL type `peerChat#36c6019a`.
// Group.
type PeerChat struct {
	// Group identifier
	ChatID int64
}

// construct implements constructor of PeerClass.
func (p PeerChat) construct() PeerClass { return &p }

// PeerUser represents TL type `peerUser#59511722`.
// Chat partner
type PeerUser struct {
	// User identifier
	UserID int64
}

// construct implements constructor of PeerClass.
func (p PeerUser) construct() PeerClass { return &p }

// FolderPeer represents TL type `folderPeer#e9baa668`.
// Peer in a folder
type FolderPeer struct {
	// Folder peer info
	Peer PeerClass
	// Peer folder ID, for more info click here¹
	FolderID int
}
```
这里的关键是必须有某种方式约束`PeerClass`只能是`PeerUser/PeerChat/PeerChannel`之一，gotd巧妙的使用未导出方法 `construct() PeerClass` 来约束只有与`PeerClass`同一包内的实现该私有方法的`PeerUser/PeerChat/PeerChannel`才能赋值给`PeerClass`变量。

Go中 switch type 断言与Rust的match type有异曲同工之妙：
* Go代码：
```go
switch v := g.(type) {
case *tg.PeerUser: // peerUser#59511722
case *tg.PeerChat: // peerChat#36c6019a
case *tg.PeerChannel: // peerChannel#a2a5371e
default: panic(v)
}
```
* 等价Rust代码：
```rust
match g {
	tg::PeerUser(user) => // peerUser#59511722
	tg::PeerChat(chat) => // peerChat#36c6019a
	tg::PeerChannel(channel) => // peerChannel#a2a5371e
	_ => None
}
```